(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react/jsx-runtime'), require('prism-react-renderer'), require('react'), require('sucrase')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react/jsx-runtime', 'prism-react-renderer', 'react', 'sucrase'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactLive = {}, global['jsx-runtime'], global.Prism, global.React, global.Sucrase));
}(this, (function (exports, jsxRuntime, Highlight, React, sucrase) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var Highlight__default = /*#__PURE__*/_interopDefaultLegacy(Highlight);
  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  var m = {
    characterData: !0,
    characterDataOldValue: !0,
    childList: !0,
    subtree: !0
  };

  function p(c) {
    var a = window.getSelection();
    a.empty();
    a.addRange(c);
  }

  function q(c) {
    return (c.metaKey || c.ctrlKey) && !c.altKey && "KeyZ" === c.code;
  }

  function r(c) {
    c = [c.firstChild];

    for (var b, a = ""; b = c.pop();) {
      b.nodeType === Node.TEXT_NODE ? a += b.textContent : b.nodeType === Node.ELEMENT_NODE && "BR" === b.nodeName && (a += "\n"), b.nextSibling && c.push(b.nextSibling), b.firstChild && c.push(b.firstChild);
    }

    "\n" !== a[a.length - 1] && (a += "\n");
    return a;
  }

  function w(c) {
    var a = window.getSelection().getRangeAt(0),
        b = a.collapsed ? 0 : a.toString().length,
        f = document.createRange();
    f.setStart(c, 0);
    f.setEnd(a.startContainer, a.startOffset);
    return {
      position: c = (f = f.toString()).length,
      extent: b,
      content: f = (f = f.split("\n"))[a = f.length - 1],
      line: a
    };
  }

  function C(c, a, b) {
    0 >= a && (a = 0);

    if (!b || 0 > b) {
      b = a;
    }

    var f = document.createRange();
    c = [c.firstChild];

    for (var d, l = 0, g = a; d = c[c.length - 1];) {
      if (d.nodeType === Node.TEXT_NODE) {
        if (l + d.textContent.length >= g) {
          var h = g - l;

          if (g === a) {
            if (g = f, h < d.textContent.length ? g.setStart(d, h) : g.setStartAfter(d), b !== a) {
              g = b;
              continue;
            } else {
              break;
            }
          } else {
            a = f;
            h < (b = d).textContent.length ? a.setEnd(b, h) : a.setEndAfter(b);
            break;
          }
        }

        l += d.textContent.length;
      } else if (d.nodeType === Node.ELEMENT_NODE && "BR" === d.nodeName) {
        if (l + 1 >= g) {
          if (g === a) {
            if (h = f, 0 < d.textContent.length ? h.setStart(d, 0) : h.setStartAfter(d), b !== a) {
              g = b;
              continue;
            } else {
              break;
            }
          } else {
            a = f;
            0 < (b = d).textContent.length ? a.setEnd(b, 0) : a.setEndAfter(b);
            break;
          }
        }

        l++;
      }

      c.pop();
      d.nextSibling && c.push(d.nextSibling);
      d.firstChild && c.push(d.firstChild);
    }

    return f;
  }

  function useEditable(c, a, b) {
    function f(k) {
      var b = c.current;

      if (b) {
        var a = w(b);
        b = r(b);
        a.position += k.length - b.length;
        e.position = a;
        e.onChange(k, a);
      }
    }

    function l(k, b) {
      var e = c.current;

      if (e) {
        var a = window.getSelection().getRangeAt(0);
        a.deleteContents();
        a.collapse();
        var d = b || 0;
        (a = C(e, b = (a = w(e)).position + (0 > d ? d : 0), a.position + (0 < d ? d : 0))).deleteContents();
        k && a.insertNode(document.createTextNode(k));
        p(C(e, b + k.length));
      }
    }

    function d(b) {
      var a = c.current;

      if (a) {
        a.focus();
        var e = 0;

        if ("number" == typeof b) {
          e = b;
        } else {
          var k = r(a).split("\n").slice(0, b.row);
          b.row && (e += k.join("\n").length + 1);
          e += b.column;
        }

        p(C(a, e));
      }
    }

    function g() {
      var b = c.current;
      return {
        text: r(b),
        position: b = w(b)
      };
    }

    function h() {
      e.observer.disconnect();
    }

    b || (b = {});
    var D = React.useState([])[1],
        e = React.useState(function () {
      var e = {
        observer: null,
        disconnected: !1,
        onChange: a,
        queue: [],
        history: [],
        historyAt: -1,
        position: null
      };
      "undefined" != typeof MutationObserver && (e.observer = new MutationObserver(function b(b) {
        var a;
        (a = e.queue).push.apply(a, b);
      }));
      return e;
    })[0],
        n = React.useMemo(function () {
      return {
        update: f,
        insert: l,
        move: d,
        getState: g
      };
    }, []);

    if ("object" != typeof navigator) {
      return n;
    }

    React.useLayoutEffect(function () {
      e.onChange = a;

      if (c.current && !b.disabled) {
        e.disconnected = !1;
        e.observer.observe(c.current, m);

        if (e.position) {
          var k = e.position,
              d = k.position;
          p(C(c.current, d, d + k.extent));
        }

        return h;
      }
    });
    React.useLayoutEffect(function () {
      if (!c.current || b.disabled) {
        e.history.length = 0, e.historyAt = -1;
      } else {
        var a = c.current;

        if (e.position) {
          a.focus();
          var d = e.position,
              f = d.position;
          p(C(a, f, f + d.extent));
        }

        var g = a.style.whiteSpace,
            h = a.contentEditable,
            l = !0;

        try {
          a.contentEditable = "plaintext-only";
        } catch (u) {
          a.contentEditable = "true", l = !1;
        }

        "pre" !== g && (a.style.whiteSpace = "pre-wrap");
        b.indentation && (a.style.tabSize = a.style.MozTabSize = "" + b.indentation);
        d = "" + " ".repeat(b.indentation || 0);

        var x,
            E = new RegExp("^(?:" + d + ")"),
            F = new RegExp("^(?:" + d + ")*(" + d + ")$"),
            t = function t(b) {
          if (c.current && e.position) {
            var u = r(a),
                d = w(a),
                f = new Date().valueOf(),
                g = e.history[e.historyAt];
            !b && 500 > f - x || g && g[1] === u ? x = f : (b = ++e.historyAt, e.history[b] = [d, u], e.history.splice(b + 1), 500 < b && (e.historyAt--, e.history.shift()));
          }
        },
            v = function v() {
          var b;
          (b = e.queue).push.apply(b, e.observer.takeRecords());
          b = w(a);

          if (e.queue.length) {
            e.observer.disconnect();
            e.disconnected = !0;
            var d = r(a);
            e.position = b;

            for (var c, f; c = e.queue.pop();) {
              null !== c.oldValue && (c.target.textContent = c.oldValue);

              for (f = c.removedNodes.length - 1; 0 <= f; f--) {
                c.target.insertBefore(c.removedNodes[f], c.nextSibling);
              }

              for (f = c.addedNodes.length - 1; 0 <= f; f--) {
                c.addedNodes[f].parentNode && c.target.removeChild(c.addedNodes[f]);
              }
            }

            e.onChange(d, b);
          }
        },
            y = function y(c) {
          if (!c.defaultPrevented && c.target === a) {
            if (e.disconnected) {
              return c.preventDefault(), D([]);
            }

            if (q(c)) {
              c.preventDefault(), c.shiftKey ? (c = ++e.historyAt, (c = e.history[c]) || (e.historyAt = e.history.length - 1)) : (c = --e.historyAt, (c = e.history[c]) || (e.historyAt = 0)), c && (e.observer.disconnect(), e.disconnected = !0, e.position = c[0], e.onChange(c[1], c[0]));
            } else {
              t();

              if ("Enter" === c.key) {
                c.preventDefault();
                var d = w(a),
                    f = /\S/g.exec(d.content);
                d = "\n" + d.content.slice(0, f ? f.index : d.content.length);
                n.insert(d);
              } else if ((!l || b.indentation) && "Backspace" === c.key) {
                c.preventDefault(), window.getSelection().getRangeAt(0).collapsed ? (d = w(a), d = F.exec(d.content), n.insert("", d ? -d[1].length : -1)) : n.insert("", 0);
              } else if (b.indentation && "Tab" === c.key) {
                c.preventDefault();
                f = (d = w(a)).position - d.content.length;
                var g = r(a);
                d = c.shiftKey ? g.slice(0, f) + d.content.replace(E, "") + g.slice(f + d.content.length) : g.slice(0, f) + (b.indentation ? " ".repeat(b.indentation) : "\t") + g.slice(f);
                n.update(d);
              }

              c.repeat && v();
            }
          }
        },
            z = function z(b) {
          b.defaultPrevented || b.isComposing || (q(b) || t(), v(), a.focus());
        },
            A = function A(b) {
          e.position = window.getSelection().rangeCount && b.target === a ? w(a) : null;
        },
            B = function B(a) {
          a.preventDefault();
          t(!0);
          n.insert(a.clipboardData.getData("text/plain"));
          t(!0);
          v();
        };

        document.addEventListener("selectstart", A);
        window.addEventListener("keydown", y);
        a.addEventListener("paste", B);
        a.addEventListener("keyup", z);
        return function () {
          document.removeEventListener("selectstart", A);
          window.removeEventListener("keydown", y);
          a.removeEventListener("paste", B);
          a.removeEventListener("keyup", z);
          a.style.whiteSpace = g;
          a.contentEditable = h;
        };
      }
    }, [c.current, b.disabled, b.indentation]);
    return n;
  }

  const theme = {
      plain: {
          color: "#C5C8C6",
          backgroundColor: "#1D1F21",
      },
      styles: [
          {
              types: ["prolog", "comment", "doctype", "cdata"],
              style: {
                  color: "hsl(30, 20%, 50%)",
              },
          },
          {
              types: ["property", "tag", "boolean", "number", "constant", "symbol"],
              style: { color: "hsl(350, 40%, 70%)" },
          },
          {
              types: ["attr-name", "string", "char", "builtin", "insterted"],
              style: {
                  color: "hsl(75, 70%, 60%)",
              },
          },
          {
              types: [
                  "operator",
                  "entity",
                  "url",
                  "string",
                  "variable",
                  "language-css",
              ],
              style: {
                  color: "hsl(40, 90%, 60%)",
              },
          },
          {
              types: ["deleted"],
              style: {
                  color: "rgb(255, 85, 85)",
              },
          },
          {
              types: ["italic"],
              style: {
                  fontStyle: "italic",
              },
          },
          {
              types: ["important", "bold"],
              style: {
                  fontWeight: "bold",
              },
          },
          {
              types: ["regex", "important"],
              style: {
                  color: "#e90",
              },
          },
          {
              types: ["atrule", "attr-value", "keyword"],
              style: {
                  color: "hsl(350, 40%, 70%)",
              },
          },
          {
              types: ["punctuation", "symbol"],
              style: {
                  opacity: 0.7,
              },
          },
      ],
  };

  const CodeEditor = (props) => {
      const editorRef = React.useRef(null);
      const [code, setCode] = React.useState(props.code || "");
      React.useEffect(() => {
          setCode(props.code);
      }, [props.code]);
      const onEditableChange = React.useCallback((_code) => {
          setCode(_code.slice(0, -1));
      }, []);
      useEditable(editorRef, onEditableChange, {
          disabled: props.disabled,
          indentation: props.tabMode === "indentation" ? 2 : undefined,
      });
      React.useEffect(() => {
          if (props.onChange) {
              props.onChange(code);
          }
      }, [code]);
      return (jsxRuntime.jsx("div", Object.assign({ className: props.className, style: props.style }, { children: jsxRuntime.jsx(Highlight__default['default'], Object.assign({ Prism: props.prism || Highlight.Prism, code: code, theme: props.theme || theme, language: props.language }, { children: ({ className: _className, tokens, getLineProps, getTokenProps, style: _style, 
              /* @ts-ignore — this property exists but the lib's types are incorrect */
              theme: _theme, }) => (jsxRuntime.jsx("pre", Object.assign({ className: _className, style: Object.assign(Object.assign({ margin: 0, outline: "none", padding: 10, fontFamily: "inherit" }, (_theme && typeof _theme.plain === "object"
                      ? _theme.plain
                      : {})), _style), ref: editorRef, spellCheck: "false" }, { children: tokens.map((line, lineIndex) => (
                  // eslint-disable-next-line react/jsx-key
                  jsxRuntime.jsxs("div", Object.assign({}, getLineProps({ line, key: `line-${lineIndex}` }), { children: [line
                              .filter((token) => !token.empty)
                              .map((token, tokenIndex) => (
                          // eslint-disable-next-line react/jsx-key
                          jsxRuntime.jsx("span", Object.assign({}, getTokenProps({ token, key: `token-${tokenIndex}` }))))), "\n"] })))) }))) })) })));
  };
  CodeEditor.defaultProps = {
      tabMode: "indentation",
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  function __rest(s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  const LiveContext = React.createContext({});

  const defaultTransforms = ["jsx", "imports"];
  function transform(opts = {}) {
      const transforms = (Array.isArray(opts.transforms)
          ? opts.transforms.filter(Boolean)
          : defaultTransforms);
      return (code) => sucrase.transform(code, { transforms }).code;
  }

  const errorBoundary = (Element, errorCallback) => {
      return class ErrorBoundary extends React.Component {
          componentDidCatch(error) {
              errorCallback(error);
          }
          render() {
              return typeof Element === "function" ? (jsxRuntime.jsx(Element, {})) : React__default['default'].isValidElement(Element) ? (Element) : null;
          }
      };
  };

  const evalCode = (code, scope) => {
      const scopeKeys = Object.keys(scope);
      const scopeValues = scopeKeys.map((key) => scope[key]);
      return new Function(...scopeKeys, code)(...scopeValues);
  };

  /**
   * Creates a new composite function that invokes the functions from right to left
   */
  function compose(...functions) {
      return functions.reduce((acc, currentFn) => (...args) => acc(currentFn(...args)));
  }

  const jsxConst = 'const _jsxFileName = "";';
  const trimCode = (code) => code.trim().replace(/;$/, "");
  const spliceJsxConst = (code) => code.replace(jsxConst, "").trim();
  const addJsxConst = (code) => jsxConst + code;
  const wrapReturn = (code) => `return (${code})`;
  const generateElement = ({ code = "", scope = {}, enableTypeScript = true }, errorCallback) => {
      /**
       * To enable TypeScript we need to transform the TS to JS code first,
       * splice off the JSX const, wrap the eval in a return statement, then
       * transform any imports. The two-phase approach is required to do
       * the implicit evaluation and not wrap leading Interface or Type
       * statements in the return.
       */
      const firstPassTransforms = ["jsx"];
      enableTypeScript && firstPassTransforms.push("typescript");
      const transformed = compose(addJsxConst, transform({ transforms: ["imports"] }), wrapReturn, spliceJsxConst, trimCode, transform({ transforms: firstPassTransforms }), trimCode)(code);
      return errorBoundary(evalCode(transformed, Object.assign({ React: React__default['default'] }, scope)), errorCallback);
  };
  const renderElementAsync = ({ code = "", scope = {}, enableTypeScript = true }, resultCallback, errorCallback
  // eslint-disable-next-line consistent-return
  ) => {
      const render = (element) => {
          if (typeof element === "undefined") {
              errorCallback(new SyntaxError("`render` must be called with valid JSX."));
          }
          else {
              resultCallback(errorBoundary(element, errorCallback));
          }
      };
      if (!/render\s*\(/.test(code)) {
          return errorCallback(new SyntaxError("No-Inline evaluations must call `render`."));
      }
      const transforms = ["jsx", "imports"];
      enableTypeScript && transforms.splice(1, 0, "typescript");
      evalCode(transform({ transforms })(code), Object.assign(Object.assign({ React: React__default['default'] }, scope), { render }));
  };

  function LiveProvider({ children, code = "", language = "tsx", theme, enableTypeScript = true, disabled = false, scope, transformCode, noInline = false, }) {
      const [state, setState] = React.useState({
          error: undefined,
          element: undefined,
      });
      function transpileAsync(newCode) {
          return __awaiter(this, void 0, void 0, function* () {
              const errorCallback = (error) => {
                  setState({ error: error.toString(), element: undefined });
              };
              // - transformCode may be synchronous or asynchronous.
              // - transformCode may throw an exception or return a rejected promise, e.g.
              //   if newCode is invalid and cannot be transformed.
              // - Not using async-await to since it requires targeting ES 2017 or
              //   importing regenerator-runtime... in the next major version of
              //   react-live, should target ES 2017+
              try {
                  const transformResult = transformCode ? transformCode(newCode) : newCode;
                  try {
                      const transformedCode = yield Promise.resolve(transformResult);
                      const renderElement = (element) => setState({ error: undefined, element });
                      if (typeof transformedCode !== "string") {
                          throw new Error("Code failed to transform");
                      }
                      // Transpilation arguments
                      const input = {
                          code: transformedCode,
                          scope,
                          enableTypeScript,
                      };
                      if (noInline) {
                          setState({ error: undefined, element: null }); // Reset output for async (no inline) evaluation
                          renderElementAsync(input, renderElement, errorCallback);
                      }
                      else {
                          renderElement(generateElement(input, errorCallback));
                      }
                  }
                  catch (error) {
                      return errorCallback(error);
                  }
              }
              catch (e) {
                  errorCallback(e);
                  return Promise.resolve();
              }
          });
      }
      const onError = (error) => setState({ error: error.toString() });
      React.useEffect(() => {
          transpileAsync(code).catch(onError);
      }, [code, scope, noInline, transformCode]);
      const onChange = (newCode) => {
          transpileAsync(newCode).catch(onError);
      };
      return (jsxRuntime.jsx(LiveContext.Provider, Object.assign({ value: Object.assign(Object.assign({}, state), { code,
              language,
              theme,
              disabled,
              onError,
              onChange }) }, { children: children })));
  }

  function LiveEditor(props) {
      const { code, language, theme, disabled, onChange } = React.useContext(LiveContext);
      return (jsxRuntime.jsx(CodeEditor, Object.assign({ theme: theme, code: code, language: language, disabled: disabled, onChange: onChange }, props)));
  }

  function LiveError(props) {
      const { error } = React.useContext(LiveContext);
      return error ? jsxRuntime.jsx("pre", Object.assign({}, props, { children: error })) : null;
  }

  const fallbackComponent = (props) => jsxRuntime.jsx("div", Object.assign({}, props));
  function LivePreview(_a) {
      var { Component = fallbackComponent } = _a, rest = __rest(_a, ["Component"]);
      const { element: Element } = React.useContext(LiveContext);
      return jsxRuntime.jsx(Component, Object.assign({}, rest, { children: Element ? jsxRuntime.jsx(Element, {}) : null }));
  }

  function withLive(WrappedComponent) {
      const WithLive = (props) => (jsxRuntime.jsx(LiveContext.Consumer, { children: (live) => jsxRuntime.jsx(WrappedComponent, Object.assign({ live: live }, props)) }));
      WithLive.displayName = "WithLive";
      return WithLive;
  }

  exports.Editor = CodeEditor;
  exports.LiveContext = LiveContext;
  exports.LiveEditor = LiveEditor;
  exports.LiveError = LiveError;
  exports.LivePreview = LivePreview;
  exports.LiveProvider = LiveProvider;
  exports.generateElement = generateElement;
  exports.renderElementAsync = renderElementAsync;
  exports.withLive = withLive;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
